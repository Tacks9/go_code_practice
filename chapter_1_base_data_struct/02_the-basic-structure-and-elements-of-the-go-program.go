package main

import (
	"fmt"
	out "fmt" // 使用别名
)

var luck int = 6

func init() {
	luck = luck * luck
}
func main() {
	fmt.Println("Hello! Go World! this is the basic structure and elements of the go program")
	out.Println("out is fmt alias")

	var a int = 10
	fmt.Println(luck * a)

}

/*
包Package
	1、用来结构化代码，每个程序都是由包组成的
	2、包名，采用小写字母。例如pack1包，编译后产生的对象文件将会是pack1.a
	3、每个go文件都只能属于某一个包的，一个包下面可以包含多个文件
	4、你必须要在每个文件开头第一行使用 `package pkg_name`来指名当前文件属于哪个包
	5、这个包的概念有点类似其他编程语言中的命名空间
标准库
	1、标准库包含大量可以直接使用的包，如`fmt`\`os`
	2、一般会位于go的根目录中的pkg目录下
包的导入
	1、包的引入通过`import`关键字来将一组包链接在一起
	2、例如 `import "fmt" `表示Go编辑器要引入fmt包。
	3、fmt包是有格式化IO相关的函数，包名采用""双引号包裹
	4、想引入多个包，可以采用多次import或者使用因式分解的方法
		import (
			"fmt"
			"os"
		)
	5、包的加载，如果包名不是以.或者/引入的，则Go会进行全局文件下查找
	6、包的加载，如果包是以./开头的，则会在相对目录下查找
	7、导入包，则表示包含这个包所有的代码对象
	8、包中的代码必须是唯一的，避免名称冲突，相同的标识符可以在不同的包中可以用包名加上标识符来进行区分
	9、包的别名，为了解决包名之间有可能冲突，可以`import out "fmt" ` 从而对包进行重新命名
	10、导入包之后，可以定义声明常量、变量、函数、等
可见性规则
	1、标识符大写字母开头，则可以被外界通过引入包进行调用。如其他语言面向对象的public
	2、标识符小写字母开头，则对包外是不可见的，但是在包内是可用的。如其他面向对象的private
程序构建
	1、包以及包内的文件必须要正确的进行编译
	2、包的依赖关系将决定构建顺序
	3、同一个包的源文件必须同时被一起编译
	4、一个包将作为一个编译的基本单元
	5、每个目录只包含一个包
	6、如果对一个包进行更改或者重新编译，那么引用这个包的程序也都必须重新编译
	7、包与包之间，显示依赖=>快速编译
	8、每段代码只会被编译一次
Go程序执行流程
	1、按顺序导入所有被main包引用的其他包，然后在每个包下面执行同样流程
	2、如果这个包又导入其他包，将递归进行执行，但是每个包只会被导入一次
	3、初始化包中的常量、变量、如果有init则进行调用
	4、执行main函数
函数
	1、一个可执行程序，必须有main函数，一般都是启动后首先执行main函数，如果有init函数则优先进行init初始化
	2、main函数既没有参数，也没有返回值
	3、函数的代码主题，"{"左大括号必须与方法声明放在同一个行，"}"右大括号放到下一行
		func functionName(parameter_list) (return_value_list) {
   			…
		}
	4、parameter_list    是函数形参，可以传入多个参数，(param1 type1, param2 type2)
	5、return_value_list 是函数返回值参数，(ret1 type1, ret2 type2)
	6、functionName      是函数名，遵循驼峰命名法，首字母大写可以被外部包调用，首字母小写则对外不可见
	7、程序正常结束退出代码为0，因为异常而进行终止的退出代码非0
注释
	1、单行注释//、多行注释
	2、注释不会被编译，godoc 工具会收集这些注释并产生一个技术文档。
	3、每一个包开始最好也有相关注释，应该提供一些相关信息并对整体功能做简要的介绍
类型
	1、使用 var 声明的变量的值会自动初始化为该类型的零值
	2、基本数据类型：int、float、bool、string
	3、结构化复合类型：struct、array、slice、map、channel、func
	4、行为描述：interface
	5、结构化的类型，没有真正的值，它使用nil作为默认值
	6、go语言中，不存在类型继承
	7、使用 type 可以为某个类型定义别名，`type IZ int`,之后我们可以声明别的变量`var a IZ = 6`
	8、type也可以使用因式分解定义别名
类型转化
	1、所有类型转化必须显性说明 valueOfTypeB = typeB(valueOfTypeA)
	2、精度问题，小范围的类型转成大范围的类型，一般不会丢失精度，反之可能会发生截断甚至编译失败
一些规范
	1、已经import引入的包，没有使用，则会提示报错
	2、已经定义的变量、没有使用，则会提示报错
	3、gofmt 来强制实现统一的代码风格

*/
